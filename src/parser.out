Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    EQ
    QUOTE
    SETQ
    STRING_END
    STRING_START

Grammar

Rule 0     S' -> statement
Rule 1     empty -> <empty>
Rule 2     statement -> empty
Rule 3     statement -> sexpr
Rule 4     sexpr -> LPAREN IDENTIFIER RPAREN
Rule 5     sexpr -> LPAREN IDENTIFIER seq RPAREN
Rule 6     sexpr -> LPAREN ADD seq RPAREN
Rule 7     sexpr -> LPAREN SUB seq RPAREN
Rule 8     sexpr -> LPAREN MUL seq RPAREN
Rule 9     sexpr -> LPAREN DIV seq RPAREN
Rule 10    sexpr -> LPAREN IF conditional sexpr RPAREN
Rule 11    sexpr -> LPAREN IF conditional sexpr sexpr RPAREN
Rule 12    conditional -> INTEGER
Rule 13    sexpr -> LPAREN PRINT seq RPAREN
Rule 14    seq -> atom
Rule 15    seq -> sexpr
Rule 16    seq -> atom seq
Rule 17    seq -> sexpr seq
Rule 18    atom -> INTEGER
Rule 19    atom -> FLOAT
Rule 20    atom -> STRING
Rule 21    atom -> IDENTIFIER

Terminals, with rules where they appear

ADD                  : 6
DIV                  : 9
EQ                   : 
FLOAT                : 19
IDENTIFIER           : 4 5 21
IF                   : 10 11
INTEGER              : 12 18
LPAREN               : 4 5 6 7 8 9 10 11 13
MUL                  : 8
PRINT                : 13
QUOTE                : 
RPAREN               : 4 5 6 7 8 9 10 11 13
SETQ                 : 
STRING               : 20
STRING_END           : 
STRING_START         : 
SUB                  : 7
error                : 

Nonterminals, with rules where they appear

atom                 : 14 16
conditional          : 10 11
empty                : 2
seq                  : 5 6 7 8 9 13 16 17
sexpr                : 3 10 11 11 15 17
statement            : 0

Parsing method: LALR

state 0

    (0) S' -> . statement
    (2) statement -> . empty
    (3) statement -> . sexpr
    (1) empty -> .
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    $end            reduce using rule 1 (empty -> .)
    LPAREN          shift and go to state 4

    statement                      shift and go to state 1
    empty                          shift and go to state 2
    sexpr                          shift and go to state 3

state 1

    (0) S' -> statement .



state 2

    (2) statement -> empty .

    $end            reduce using rule 2 (statement -> empty .)


state 3

    (3) statement -> sexpr .

    $end            reduce using rule 3 (statement -> sexpr .)


state 4

    (4) sexpr -> LPAREN . IDENTIFIER RPAREN
    (5) sexpr -> LPAREN . IDENTIFIER seq RPAREN
    (6) sexpr -> LPAREN . ADD seq RPAREN
    (7) sexpr -> LPAREN . SUB seq RPAREN
    (8) sexpr -> LPAREN . MUL seq RPAREN
    (9) sexpr -> LPAREN . DIV seq RPAREN
    (10) sexpr -> LPAREN . IF conditional sexpr RPAREN
    (11) sexpr -> LPAREN . IF conditional sexpr sexpr RPAREN
    (13) sexpr -> LPAREN . PRINT seq RPAREN

    IDENTIFIER      shift and go to state 5
    ADD             shift and go to state 6
    SUB             shift and go to state 7
    MUL             shift and go to state 8
    DIV             shift and go to state 9
    IF              shift and go to state 10
    PRINT           shift and go to state 11


state 5

    (4) sexpr -> LPAREN IDENTIFIER . RPAREN
    (5) sexpr -> LPAREN IDENTIFIER . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    RPAREN          shift and go to state 13
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 14
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 6

    (6) sexpr -> LPAREN ADD . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 20
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 7

    (7) sexpr -> LPAREN SUB . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 21
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 8

    (8) sexpr -> LPAREN MUL . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 22
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 9

    (9) sexpr -> LPAREN DIV . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 23
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 10

    (10) sexpr -> LPAREN IF . conditional sexpr RPAREN
    (11) sexpr -> LPAREN IF . conditional sexpr sexpr RPAREN
    (12) conditional -> . INTEGER

    INTEGER         shift and go to state 25

    conditional                    shift and go to state 24

state 11

    (13) sexpr -> LPAREN PRINT . seq RPAREN
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    seq                            shift and go to state 26
    atom                           shift and go to state 15
    sexpr                          shift and go to state 16

state 12

    (21) atom -> IDENTIFIER .

    INTEGER         reduce using rule 21 (atom -> IDENTIFIER .)
    FLOAT           reduce using rule 21 (atom -> IDENTIFIER .)
    STRING          reduce using rule 21 (atom -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 21 (atom -> IDENTIFIER .)
    LPAREN          reduce using rule 21 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 21 (atom -> IDENTIFIER .)


state 13

    (4) sexpr -> LPAREN IDENTIFIER RPAREN .

    $end            reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    INTEGER         reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    FLOAT           reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    STRING          reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    IDENTIFIER      reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)
    RPAREN          reduce using rule 4 (sexpr -> LPAREN IDENTIFIER RPAREN .)


state 14

    (5) sexpr -> LPAREN IDENTIFIER seq . RPAREN

    RPAREN          shift and go to state 27


state 15

    (14) seq -> atom .
    (16) seq -> atom . seq
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    RPAREN          reduce using rule 14 (seq -> atom .)
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    atom                           shift and go to state 15
    seq                            shift and go to state 28
    sexpr                          shift and go to state 16

state 16

    (15) seq -> sexpr .
    (17) seq -> sexpr . seq
    (14) seq -> . atom
    (15) seq -> . sexpr
    (16) seq -> . atom seq
    (17) seq -> . sexpr seq
    (18) atom -> . INTEGER
    (19) atom -> . FLOAT
    (20) atom -> . STRING
    (21) atom -> . IDENTIFIER
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    RPAREN          reduce using rule 15 (seq -> sexpr .)
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    IDENTIFIER      shift and go to state 12
    LPAREN          shift and go to state 4

    sexpr                          shift and go to state 16
    seq                            shift and go to state 29
    atom                           shift and go to state 15

state 17

    (18) atom -> INTEGER .

    INTEGER         reduce using rule 18 (atom -> INTEGER .)
    FLOAT           reduce using rule 18 (atom -> INTEGER .)
    STRING          reduce using rule 18 (atom -> INTEGER .)
    IDENTIFIER      reduce using rule 18 (atom -> INTEGER .)
    LPAREN          reduce using rule 18 (atom -> INTEGER .)
    RPAREN          reduce using rule 18 (atom -> INTEGER .)


state 18

    (19) atom -> FLOAT .

    INTEGER         reduce using rule 19 (atom -> FLOAT .)
    FLOAT           reduce using rule 19 (atom -> FLOAT .)
    STRING          reduce using rule 19 (atom -> FLOAT .)
    IDENTIFIER      reduce using rule 19 (atom -> FLOAT .)
    LPAREN          reduce using rule 19 (atom -> FLOAT .)
    RPAREN          reduce using rule 19 (atom -> FLOAT .)


state 19

    (20) atom -> STRING .

    INTEGER         reduce using rule 20 (atom -> STRING .)
    FLOAT           reduce using rule 20 (atom -> STRING .)
    STRING          reduce using rule 20 (atom -> STRING .)
    IDENTIFIER      reduce using rule 20 (atom -> STRING .)
    LPAREN          reduce using rule 20 (atom -> STRING .)
    RPAREN          reduce using rule 20 (atom -> STRING .)


state 20

    (6) sexpr -> LPAREN ADD seq . RPAREN

    RPAREN          shift and go to state 30


state 21

    (7) sexpr -> LPAREN SUB seq . RPAREN

    RPAREN          shift and go to state 31


state 22

    (8) sexpr -> LPAREN MUL seq . RPAREN

    RPAREN          shift and go to state 32


state 23

    (9) sexpr -> LPAREN DIV seq . RPAREN

    RPAREN          shift and go to state 33


state 24

    (10) sexpr -> LPAREN IF conditional . sexpr RPAREN
    (11) sexpr -> LPAREN IF conditional . sexpr sexpr RPAREN
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    LPAREN          shift and go to state 4

    sexpr                          shift and go to state 34

state 25

    (12) conditional -> INTEGER .

    LPAREN          reduce using rule 12 (conditional -> INTEGER .)


state 26

    (13) sexpr -> LPAREN PRINT seq . RPAREN

    RPAREN          shift and go to state 35


state 27

    (5) sexpr -> LPAREN IDENTIFIER seq RPAREN .

    $end            reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    INTEGER         reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    FLOAT           reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    STRING          reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    IDENTIFIER      reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    LPAREN          reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)
    RPAREN          reduce using rule 5 (sexpr -> LPAREN IDENTIFIER seq RPAREN .)


state 28

    (16) seq -> atom seq .

    RPAREN          reduce using rule 16 (seq -> atom seq .)


state 29

    (17) seq -> sexpr seq .

    RPAREN          reduce using rule 17 (seq -> sexpr seq .)


state 30

    (6) sexpr -> LPAREN ADD seq RPAREN .

    $end            reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    INTEGER         reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    FLOAT           reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    STRING          reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    IDENTIFIER      reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    LPAREN          reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)
    RPAREN          reduce using rule 6 (sexpr -> LPAREN ADD seq RPAREN .)


state 31

    (7) sexpr -> LPAREN SUB seq RPAREN .

    $end            reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    INTEGER         reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    FLOAT           reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    STRING          reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    IDENTIFIER      reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    LPAREN          reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)
    RPAREN          reduce using rule 7 (sexpr -> LPAREN SUB seq RPAREN .)


state 32

    (8) sexpr -> LPAREN MUL seq RPAREN .

    $end            reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    INTEGER         reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    FLOAT           reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    STRING          reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    IDENTIFIER      reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    LPAREN          reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)
    RPAREN          reduce using rule 8 (sexpr -> LPAREN MUL seq RPAREN .)


state 33

    (9) sexpr -> LPAREN DIV seq RPAREN .

    $end            reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    INTEGER         reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    FLOAT           reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    STRING          reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    IDENTIFIER      reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    LPAREN          reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)
    RPAREN          reduce using rule 9 (sexpr -> LPAREN DIV seq RPAREN .)


state 34

    (10) sexpr -> LPAREN IF conditional sexpr . RPAREN
    (11) sexpr -> LPAREN IF conditional sexpr . sexpr RPAREN
    (4) sexpr -> . LPAREN IDENTIFIER RPAREN
    (5) sexpr -> . LPAREN IDENTIFIER seq RPAREN
    (6) sexpr -> . LPAREN ADD seq RPAREN
    (7) sexpr -> . LPAREN SUB seq RPAREN
    (8) sexpr -> . LPAREN MUL seq RPAREN
    (9) sexpr -> . LPAREN DIV seq RPAREN
    (10) sexpr -> . LPAREN IF conditional sexpr RPAREN
    (11) sexpr -> . LPAREN IF conditional sexpr sexpr RPAREN
    (13) sexpr -> . LPAREN PRINT seq RPAREN

    RPAREN          shift and go to state 37
    LPAREN          shift and go to state 4

    sexpr                          shift and go to state 36

state 35

    (13) sexpr -> LPAREN PRINT seq RPAREN .

    $end            reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    INTEGER         reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    FLOAT           reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    STRING          reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    IDENTIFIER      reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    LPAREN          reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)
    RPAREN          reduce using rule 13 (sexpr -> LPAREN PRINT seq RPAREN .)


state 36

    (11) sexpr -> LPAREN IF conditional sexpr sexpr . RPAREN

    RPAREN          shift and go to state 38


state 37

    (10) sexpr -> LPAREN IF conditional sexpr RPAREN .

    $end            reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    INTEGER         reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    FLOAT           reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    STRING          reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    IDENTIFIER      reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    LPAREN          reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)
    RPAREN          reduce using rule 10 (sexpr -> LPAREN IF conditional sexpr RPAREN .)


state 38

    (11) sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .

    $end            reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    INTEGER         reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    FLOAT           reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    STRING          reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    IDENTIFIER      reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    LPAREN          reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)
    RPAREN          reduce using rule 11 (sexpr -> LPAREN IF conditional sexpr sexpr RPAREN .)

